# MIPT-CAOS-Cheat-Repo

<p align="center"> 
<img src="assets/local-meme.jpg">
</p>

***Moscow Institute of Physics and Technology****, Department of Innovation and High Technology, Computer Architectures and Operating Systems course solutions. Applied Mathematics and Computer Science. Fall 2019.*

**Contribution:** create pull request with new folder containing your solutions.

***<center>!!! USE AT YOUR OWN RISK !!!</center>***

## Problem inf01-0: c/generic/sum-numbers

На стандартном потоке ввода подается последовательно вещественное число x и целое число в 16-ричной записи y.

Единственным аргументов программы является целое число z в 27-ричной системе исчисления.

Необходимо вывести вычислить значение x+y+z и вывести его на стандартный поток вывода с точностью до 3-го знака после точки.

## Problem inf01-1: generic/ieee754/classify

Реализуйте функцию с прототипом:

```
typedef enum {
    PlusZero      = 0x00,
    MinusZero     = 0x01,
    PlusInf       = 0xF0,
    MinusInf      = 0xF1,
    PlusRegular   = 0x10,
    MinusRegular  = 0x11,
    PlusDenormal  = 0x20,
    MinusDenormal = 0x21,
    SignalingNaN  = 0x30,
    QuietNaN      = 0x31
} float_class_t;

extern float_class_t
classify(double *value_ptr);
```
      

которая классифицирует специальные значения вещественного числа, на которое указывает value_ptr, в соответствии со стандартом IEEE 754.

При решении допускается использовать только побитовые операции, включая сдвиги.

## Problem inf01-2: c/ints/satsum

Реализовать функцию с прототипом:

```
uint16_t satsum(uint16_t x, uint16_t y);
```

которая выполняет сложение с насыщением, то есть, в случае целочисленного переполнения возвращает максимально возможное целое число для данного типа данных.

В коде программы запрещено использовать константы, отличные от 0 и 1.

Запрещено использовать платформо-зависимые или компиляторо-зависимые функции, типы данных с повышенной разрядностью или вещественные типы даннх.

## Problem inf01-3: c/ints/min-bytes-for-hex

В аргументах командной строки задаются целые неотрицательные числа в шетнадцатеричной системе исчисления в синтаксисе языка Си.

Для каждого числа определить минимально необходимое количество байт, которое требуется для того, чтобы можно было хранить эти числа.

## Problem inf01-4: c/ints/bitset-calc

Реализуйте калькулятор выражений над множествами в обратной польской записи.

На стандартном потоке ввода задается последовательность, состоящая из символов-значений, и символов-операций.

Значениями являются цифры от 0 до 9, и буквы английского алфавита (заглавные и строчные). Последовательности значений кодируют множества из 62 элементов.

Операциями являются:

* & - пересечение множеств;
* | - объединение множеств;
* ^ - симметрическая разность;
* ~ - дополнение текущего результата до полного множества.

В начальный момент времени, множество-результат является пустым. При чтении символов со стандартного потока ввода, когда встречается символ операции, то эта операция применяется к множеству-результату и последнему прочитанному множеству (как в обратной польской записи).

Вывести на экран полученное итоговое значение множества в нормализованной форме: сначала цифры, затем заглавные буквы, потом - строчные (упорядоченные по алфавиту).

Для хранения множеств использовать, суммарно, не более 16 байт памяти.

## Problem inf01-5: c/texts/utf8-count-symbols

На стандартном потоке ввода подается последовательность символов в кодировке UTF-8.

Посчитать количество символов, которые могут быть представлены в кодирове ASCII, и количество символов, которые не могут быть представлены в этой кодировке.

На стандартный поток вывода вывести последовательно два эти числа.

В случае ошибки декодирования потока данных, необходимо вывести результаты подсчёта, полученные на момент обнаружения ошибки, и завершить работу программы с кодом ошибки 1.

Запрещается использовать какие-либо функции стандартной библиотеки, за исключением функций ввода. Используйте только битовые операции.

Не забывайте о том, что символ перевода строки \n является легальным ASCII-символом.

## Problem inf02-0: asm-arm/basics/expression

Реализуйте функцию с меткой f, которая вычисляет значение выражения y=Ax2+Bx+C

Значения A, B, C и x хранятся, соответсвенно, в регистрах r0, r1, r2 и r3.

Результат вычисления выражения сохраните в регистре r0.

Все аргументы и значение выражения представимы 32-разрядными знаковыми целыми числами.

Использовать оперативную память запрещено, - можно использовать только регистры.

## Problem inf02-1: asm-arm/basics/memaccess

Реализуйте на языке ассемблера ARM функцию с сигнатурой:

```
int summ(int x0, int N, int *X);
```

Функция должна вычислять значение x0+∑xi, где 0<e;i<N

## Problem inf02-2: asm-arm/basics/eqsolution

Реализуйте функцию solve, с прототипом

```
int solve(int A, int B, int C, int D);
```   

которая находит минимальное значение x ∈[0,254], которое является одним из корней уравнения: Ax3+Bx2+Cx+D=0.

Все аргументы и значение выражения представимы 32-разрядными знаковыми целыми числами.

Не забывайте про сохраняемые регистры; можно использовать для этого память на стеке.

Гарантируется, что на тестовых данных существует целочисленное решение.

## Problem inf03-0: asm-arm/basics/format_io

Реализуйте программу, которая вычисляет сумму двух целых десятичных чисел. Размер типа равен размеру машинного слова.

Можно использовать функции стандартной библиотеки языка Си scanf и printf.

В качестве точки входа можно считать функцию main.

## Problem inf03-1: asm-arm/basics/char-filter-digits

Напишите программу, которая читает со стандартного потока ввода последовательность символов, и выводит только те из них, которые являются десятичными цифрами от 0 до 9.

Можно использовать функции стандартной библиотеки языка Си: fgetc и fputc.

В качестве точки входа можно считать функцию main.

## Problem inf03-2: asm-arm/basics/reverse-print-chars

Реализуйте программу, которая считывает символы со стандартного потока ввода, а затем выводит их в обратном порядке.

Можно использовать функции стандартной библиотеки языка Си: fgetc, fputc, realloc и free.

В качестве точки входа можно считать функцию main.

## Problem inf03-3: asm-arm/structs/fieldsort

Заданы описание структуры и прототип функции:

```
typedef struct Person {
    uint32_t  id;
    uint8_t   age;
    char      first_name[20];
    char      last_name[20];
} person_t;

extern void
sort_by_age(int N, person_t *persons);
```

Реализуйте функию sort_by_age, которая сортирует массив persons из N элементов в порядке возрастания поля age.

Можно использовать любой алгоритм сортировки, в том числе имеющий сложность O(N²).

## Problem advanced-1: asm-arm/codegen/compileexpr-1

Реализуйте на языке Си или C++ (не забываете в этом случае про extern "C") функцию с прототипом:

```
typedef struct {
    const char * name;
    void       * pointer;
} symbol_t;

extern void
jit_compile_expression_to_arm(const char * expression,
                              const symbol_t * externs,
                              void * out_buffer);
```
      

В аргументе expression содержится строка-арифметическое выражение, которая может содержать:

* целочисленные константы;
* имена целочисленных глобальных (extern int) переменных;
* имена функций, которые возвращают значения типа int, и могут иметь от 0 до 4 аргументов типа int;
* операторы сложения, вычитания и умножения;
* подвыражения, заключенные в скобки.

Все пробельные символы в строке нужно ингорировать. Гарантируется, что строка содержит синтаксически и семантически корректное выражение.

В аргументе externs содержится массив структур, описывающий внешние символы (как переменные, так и функции). Признаком конца массива является структура с нулевыми указателями: {.name=0, .pointer=0}

В аргументе out_buffer находятся указатель на уже выделенный блок памяти, который, после выполнения требуемой функции, должен содержать машинный код программы, реализующей вычисление значения выражения.

Функция должна заполнить этот блок (размером 4096 байт) кодом программы для процессора ARM. Использовать 32-битное кодирование инструкций. По заданному адресу должен располагаться код программы, который ведёт себя как обычная функция, то есть должны выполняться gnueabi-соглашения по сохранению регистров, а после выполнения кода, - выполнить возврат из из функции по адресу, указанному в регистре lr.

## Problem inf04-0: asm-x86/basics

Реализуйте две функции на языке ассемблера x86 (IA-32) или x86-64 с сигнатурами:

```
extern int N;
extern int *A;
extern int *B;
extern int *R;

extern void summ();
extern void everyday795(int X, int Y);
```

Первая функция вычисляет значения Ri=Ai+Bi для всех i от 0 до N.

Вторая функция:

1. вводит с клавиатуры знаковое целое число;
2. умножает его на X;
3. прибавляет к нему Y;
4. выводит результат на экран.

## Problem inf04-1: asm-x86/arrays

Реализуйте функцию на языке ассемблера x86 (IA-32) или x86-64 с сигнатурой:

```
extern void summ(int N, const int *A, const int *B, int *R);
```

Функция вычисляет значения Ri=Ai+Bi для всех i от 0 до N.

Память для хранения массива-результата уже выделена.

## Problem inf04-2: asm-x86/mergesort

Implement a function on asm-x86 (IA-32) or x86-64 with this signature:

```
extern void mergesort(int from, int to, const int *in, int *out);
```   

This function should do merge sort of integers.

Parameters from and to are indices of left and right boundaries of sorting areas; in is a source array, out - a pointer to the allocated memory for the result.

Use only stack memory, usage of the heap is forbidden.

## Problem inf05-0: asm-x86/fpu-sse/fpu-sse-intro

Реализуйте на языке ассемблера x86 (IA-32) или x86-64 две функции с сигнатурами:

```
extern double
calc(double A, double B, double C, int D);

extern void
vector_sum(int N, const float *A, const float *B, float *R);
```

Первая функция вычисляет значение выражения (A+B)/(C+D) и возвращает результат. Можно использовать как вычисления с помощью i387 FPU (только x86), так и с помощью инструкций SSE (x86 и x86-64).

Вторая функция вычисляет поэлементную сумму R[i]=A[i]+B[i]. Гарантируется, что число N больше нуля и кратно 4, а адреса массивов выровнены в памяти по границе 32 байта. Используйте векторные инструкции для вычисления.

## Problem inf05-1: asm-x86/fpu-sse/trig-macloren-series

Реализуйте на языке ассемблера x86 (IA-32) или x86-64 функцию с сигнатурой:

extern double my_sin(double x)

которая вычисляет значение sin(x).

Запрещено использовать встроенные тригонометрические инструкции.

Для вычислений используйте известный вам из курса Математического анализа способ разложения функции в ряд. Точность результата должна быть маскимально возможной для типа данных double. 

## Problem inf05-2: asm-x86/fpu-sse/vector-dot-product

Реализуйте на языке ассемблера x86 (IA-32) или x86-64 функцию с сигнатурой:

```
extern float dot_product(int N, const float *A, const float *B);
```

которая вычисляет скалярное произведение векторов A и B.

Гарантируется, что N больше нуля, но не гарантируется, что N кратно четырём.

Значения исходных векторов хранятся в произвольных адресах памяти, поэтому выравнивание для них не гарантируется.

Необходимо минимизировать количество выполняемых вычислительных инструкций, используя векторные вычисления. Доступен набор команд SSE 4.2. Для архитектуры x86-64 также доступен набор команд AVX.

## Problem inf05-3: generic/sse-matrix-mul

Напишите программу умножения двух вещественных матриц типа float.

Используйте векторные инструкции таким образом, чтобы минимизировать количество вычислений. Гарантируется поддержка SSE 4.2 и AVX. Можно использовать стандарт Си-2011.

Запрещается использовать OpenMP (для тех, кто знаком с этой технологией).

При чтении данных со стандартного потока ввода необходимо размещать данные в памяти наиболее выгодным для умножения матриц способом.

## Problem advanced-2: generic/sse-blend-images

Напишите программу, которая принимает три аргумента:

1. имя файла исходного изображения;
2. имя файла второго изображения;
3. имя выходного файла.

Все изображения - в формате Windows BMP, 32 бит на пиксель (ARGB).

Используйте векторные инструкции SSE или AVX (но не AVX2) для одновременной обработки нескольких пикселей.

Необходимо "приклеить" одно изображение поверх другого. Пример:

| argv[1]                        | argv[2]                        | argv[3]                        |
|--------------------------------|--------------------------------|--------------------------------|
| ![source0](assets/source0.bmp) | ![source0](assets/source1.bmp) | ![source0](assets/source2.bmp) |

## Problem inf06-0: asm-x86/syscalls/hello-world

Реализуйте на языке ассемблера x86 или x86_64 программу, которая выводит "Hello, World!".

Использование стандартной библиотеки Си запрещено.

Точка входа в программу - функция _start.

## Problem inf06-1: asm-x86/syscalls/copy-stream

Реализуйте на языке ассемблера x86 или x86_64 программу, которая копирует содержимое со стандартного потока ввода на стандартный поток вывода.

Использование стандартной библиотеки Си запрещено.

Точка входа в программу - функция _start.

## Problem inf06-2: asm-x86/syscalls/reverse-print-lines

Реализуйте на языке ассемблера x86 или x86_64 программу, которая читает со стандартного потока ввода текст, после чего выводит все строки текста в обратном порядке.

Использование стандартной библиотеки Си запрещено.

Точка входа в программу - функция _start.

## Problem inf07-0: files-io/read-filter-write

Программе в аргументах командной строки передаются три имени файла. Первый аргумент - входной файл, два остальных - выходные.

Реализуйте программу, которая читает символы из первого файла, во второй файл записывает только цифры, а в третий - всё остальное.

Разрешается использовать только низкоуровневый ввод-вывод POSIX.

Если входной файл не существует, то нужно завершить работу с кодом 1.

Если не возможно создать один из выходных файлов, то завершить работу с кодом 2.

При возникновении других ошибок ввода-вывода - завершить работу с кодом 3.

## Problem inf07-1: files-io/print-list-posix

Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.

Файл хранит внутри себя односвязный список элементов:

```
struct Item
{
  int value;
  uint32_t next_pointer;
};
```

Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.

Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.

Выведите на экран значения элементов в списке в текстовом представлении.

Для работы с файлом использовать только низкоуровневый ввод-вывод POSIX.

## Problem inf07-1-WINAPI: files-io/print-list-winapi

Задача, аналогичная print-list-posix, но требуется решение под Windows.

Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.

Файл хранит внутри себя односвязный список элементов:

```
struct Item
{
  int value;
  uint32_t next_pointer;
};
```

Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.

Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.

Выведите на экран значения элементов в списке в текстовом представлении.

Для работы с файлом использовать только низкоуровневый ввод-вывод WinAPI.

## Problem inf07-2: posix/filesystem/file-list-summ-size

Программе на стандартном потоке ввода передаётся список имён файлов.

Необходимо посчитать суммарный размер в байтах всех файлов, которые являются регулярными.

## Problem inf07-3: posix/filesystem/find-invalid-executables

Программе на стандартном потоке ввода передаётся список имён файлов.

Необходимо вывести на стандартный поток вывода имена "неправильных" выполняемых файлов, то есть файлов, которые отмечены как исполняемые, но при этом они заведомо не могут быть выполнены в системе (не начинаются с корректной строки #!, содержащей запускаемый интерпретатор, и не являются ELF-файлами).

## Problem inf07-4: posix/filesystem/manage-symlinks

Программе на стандартном потоке ввода передаётся список имён файлов.

Если файл является символической ссылкой, то нужно вывести абсолютное имя того файла, на который эта ссылка указывает.

Если файл является регулярным, то необходимо создать символическую ссылку в текущем каталоге, приписав в названии файла префикс link_to_.

## Problem inf08-0: posix/mmap/find-substrings-in-file

Программе передаются два аргумента: имя файла, и строка для поиска.

Необходимо найти все вхождения строки в текстовом файле, используя отображение на память с помощью системного вызова mmap.

На стандартный поток вывода вывести список всех позиций (с нуля) в файле, где втречаются строка.

## Problem inf08-1: posix/mmap/print-list-using-mmap

Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.

Файл хранит внутри себя односвязный список элементов:

struct Item {
  int value;
  uint32_t next_pointer;
};

Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.

Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.

Выведите на экран значения элементов в списке в текстовом представлении.

Используйте отображение содержимого файла на память.

## Problem inf08-2: posix/mmap/make-spiral-file

Программе передаются три аргумента: имя файла, положительное целое число N - размер квадратной матрицы, и положительное число W - ширина клетки матицы в символах.

Необходимо в указанном файле сформировать текст, который содержит матрицу, состоящую из чисел от 1 до N², таким образом, чтобы числа заполняли её по спирали, по часовой стрелке.

Числа должны быть выровнены по правой границе ячейки матрицы.

Используйте mmap для записи в файл.

Можно использовать функции форматного вывода для преобразования числа в строку.

## Problem advanced-3: posix/mmap/swap-file-mem-allocator

Необходимо реализовать функциональность функций, аналогичных malloc и free, которые выделяют память в явно заданном swap-файле (файле подкачки), который существует на диске, и имеет некоторый фиксированный размер.

Реализуйте функции:

```
extern void*
my_malloc(size_t size);

extern void
my_free(void *ptr);
```

которые ведут аналогичным образом с malloc и free.

А также функции, которые вызываются один раз: в начале работы программы, и в конце:

```
extern void
myalloc_initialize(int fd /* открытый на R/W файловый дескриптор существующего файла */);

extern void
myalloc_finalize();
```

Используйте стратегию наиболее экономичного расхода памяти в файле подкачки.

## Problem inf09-0: posix/fork/test-proc-limit

Определите экспериментальным способом, какое максимальное колчичество процессов можно запустить с установленными в ejudge лимитами.

Запрещается использовать getrlimit, и другие явные способы определения ограничений.

## Problem inf09-1: posix/fork/proc-print-numbers

Программе передается аргумент - целое число N > 0.

Необходимо создать N-1 дополнительных процессов таким образом, чтобы у каждого процесса было не более одного дочернего процесса.

Каждый из процессов должен вывести на стандартный поток ввода ровно одно число таким образом, чтобы вы выходе получилась строка:

```
1 2 3 4 ... N
```

Внимание! В этой задаче будет сравнение с учетом пробельных символов. Между числами должен быть ровно один пробел, а завершается строка символом перевода строки.

## Problem inf09-2: posix/fork/proc-count-words

На стандартном потоке ввода задается строка текста, которая состоит слова (последовательности непробельных символов), между которыми может быть произвольное количество пробельных символов, включая перевод строки.

Необходимо посчитать количество слов, если известно, что их не больше, чем 255, и вывести это значение на стандартный поток вывода.

Используйте создание новых процессов таким образом, чтобы каждый процесс читал не более одного слова, например, c помощью scanf("%s", ...).

Вывод результата возможен только из того процесса, который запущен самым первым (т.е. из исходной программы).

Итоговая программа должна вернуться с кодом возврата 0.

Размер каждого слова не превышает 4096 байт.

## Problem inf10-0: posix/signals/count-sigint

Программа при запуске сообщает на стандартный поток вывода свой PID, **выталкивает буфер вывода с помощью fflush**, после чего начинает обрабатывать поступающие сигналы.

При поступлении сигнала SIGTERM необходимо вывести на стандартный поток вывода целое число: количество ранее поступивших сигналов SIGINT и завершить свою работу.

Семантика повединия сигналов (Sys-V или BSD) считается не определенной.

## Problem inf10-1: posix/signals/do-actions

Программа при запуске сообщает на стандартный поток вывода свой PID, после чего читает со стандартного потока вывода целое число - начальное значение, которое затем будет изменяться.

При поступлении сигнала SIGUSR1 увеличить текущее значение на 1 и вывести его на стандартный поток вывода.

При поступлении сигнала SIGUSR2 - умножить текущее значение на -1 и вывести его на стандартный поток вывода.

Семантика повединия сигналов (Sys-V или BSD) считается не определенной.

Не забывайте выталкивать буфер вывода.

## Problem inf10-2: posix/signals/write-fifo

Программе в качестве аргументов передаётся имя FIFO-канала, который нужно создать, и целое неотрицательное число N.

На стандартном потоке ввода сообщается целое число - PID процесса, который необходимо оповестить о том, что канал создан, отправив ему сигнал SIGHUP.

После этого - попытаться записать в канал последовательность целых чисел от 0 до N включительно (в текстовом виде, разделяя пробелами).

Не гарантируется, что канал не будет закрыт раньше, чем будут записаны все числа. На стандартный поток вывода необходимо вывести, сколько значений удалось записать.

## Problem inf11-0: posix/signals/signalfd-rtsig

Программе в качестве аргументов передаются N имен текстовых файлов.

Программа должна обрабатывать множество сигналов от SIGRTMIN до SIGRTMAX, причем номер сигнала в диапазоне от SIGRTMIN+1 определяет порядковый номер файла из аргументов:

```
x = signo - SIGRTMIN; // SIGRTMIN <= signo <= SIGRTMAX
                      // 1 <= x <= SIGRTMAX-SIGRTMIN
```

При получении очередного сигнала необходимо прочитать одну строку из определенного файла и вывести её на стандартный поток вывода.

При получении сигнала с номером SIGRTMIN, т.е. при номере аргумента, равным 0, - корректно завершить свою работу с кодом 0.

Все остальные сигналы нужно игнорировать.

Если для вывода используются высокоуровневые функции стандартной библиотеки Си, то необходимо выталкивать буфер обмена после вывода каждой строки.

## Problem inf11-1: posix/signals/ping-pong-using-signals

Программа обрабатывать сигнал SIGRTMIN, вместе с которым передается некоторое беззнаковой 32-битное целое число N.

Все остальные сигналы нужно игнорировать.

При получении очередного сигнала нужно уменьшить это число на единицу и отправить его обратно тому процессу, который его послал (используя тот же самый сигнал).

Взаимодействие останавливается при получении значения N==0, после чего нужно корректно завершить работу.

Запрещается использовать signalfd, программа будет компилироваться без поддержки Linux-специфичных расширений.

## Problem inf11-2: posix/signals/timeout

Реализовать примерный аналог стандартной команды timeout.

Первый аргумент - количество секунд астрономического времени, которое разрешено выполняться команде. Последующие аргументы - это сама программа, которую нужно выполнить, и её аргументы.

Если управляемая программа завершается добровольно в отведенное время, то необходимо вывести на стандартный поток вывода текст ok и вернуть код возврата 0.

Если управляемая программа завершается вследствии сигнала, то нужно вывести на стандартный поток вывода текст signaled и вернуть код возврата 1.

Если управляемая программа работает дольше, то нужно вывести на стандартный поток вывода текст timeout и завершить её сигналом SIGTERM, и завершить свою работу с кодом возврата 2.

## Problem inf12-0: posix/exec/exec-python

Программе на стандартный поток ввода задается некоторое арифметическое выражение в синтаксисе языка python3.

Необходимо вычислисть это выражение, и вывести результат.

Использовать дополнительные процессы запрещено.

## Problem inf12-1: posix/exec/exec-gcc

Программе на стандартном потоке ввода задается выражение в синтаксисе языка Си.

Необходимо вычислить значение этого выражения (итоговый результат представим типом int) и вывести его на стандартный поток вывода.

## Problem inf12-2: posix/exec/exec-cgi

Программе на стандартном потоке ввода задается текст вида

```
GET /some_path/script.py?a=123&b=abrakadabra HTTP/1.1
Host: www.example.com
```

Обратите внимание на последнюю пустую строку.

Необходимо сформировать и вывести на стандартный поток вывода HTTP-ответ, который в случае успеха имеет вид:

```
HTTP/1.1 200 OK
[содержимое вывода скрипта]
```

Если указанный файл не существует, то необходимо вывести текст

```
HTTP/1.1 404 ERROR
```

Если файл существует, но не является выполняемым, то текст

```
HTTP/1.1 403 ERROR
```

У скрипта могут (но не обязаны) быть CGI-параметры, которые ему нужно передавать для обработки.

Необходимо реализовать поддержку только GET-запросов, но не POST.

Гарантируется, что входные данных содержат только синтаксически корректные запросы.

Необходимо реализовать поддержку следующих переменных окружения:

* HTTP_HOST
* QUERY_STRING
* REQUEST_METHOD
* SCRIPT_NAME
